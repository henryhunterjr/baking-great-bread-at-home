import OpenAI from 'openai';
import { v4 as uuidv4 } from 'uuid';
import { logInfo, logError } from '@/utils/logger';
import { RecipeData } from '@/types/recipeTypes';
import { isAIConfigured, getOpenAIApiKey } from './key-management';

const defaultRecipeImage = 'https://images.unsplash.com/photo-1555507036-ab1f4038808a?q=80&w=1000&auto=format&fit=crop';

export interface RecipeGenerationResponse {
  success: boolean;
  recipe?: RecipeData;
  error?: string;
}

/**
 * Generate recipe with OpenAI
 */
export const generateRecipeWithOpenAI = async (query: string): Promise<RecipeGenerationResponse> => {
  if (!isAIConfigured()) {
    return {
      success: false,
      error: 'OpenAI API key is not configured.'
    };
  }
  
  const apiKey = getOpenAIApiKey();
  
  if (!apiKey) {
    return {
      success: false,
      error: 'No OpenAI API key found.'
    };
  }
  
  try {
    const openai = new OpenAI({ apiKey: apiKey });
    
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: 'You are a helpful assistant that generates recipes based on user queries. ' +
            'Please provide a detailed recipe, including ingredients, instructions, and any helpful tips.'
        },
        {
          role: 'user',
          content: `Generate a recipe for: ${query}`
        }
      ],
      temperature: 0.7,
      max_tokens: 1000,
      n: 1,
      stop: null,
    });
    
    const recipeText = completion.choices[0].message.content;
    
    if (!recipeText) {
      return {
        success: false,
        error: 'Could not generate recipe text.'
      };
    }
    
    // Basic parsing of the generated text
    const recipe: RecipeData = {
      title: `AI Generated Recipe for ${query}`,
      introduction: `This recipe was generated by AI based on the query: ${query}.`,
      ingredients: [],
      instructions: [],
      notes: [],
      tips: [],
      isConverted: true
    };
    
    return {
      success: true,
      recipe: recipe
    };
  } catch (error) {
    logError('Error generating recipe with OpenAI', { error });
    return {
      success: false,
      error: 'Failed to generate recipe with OpenAI.'
    };
  }
};

/**
 * Process recipe text with OpenAI
 */
export const processRecipeText = async (text: string): Promise<RecipeGenerationResponse> => {
  if (!isAIConfigured()) {
    return {
      success: false,
      error: 'OpenAI API key is not configured.'
    };
  }
  
  const apiKey = getOpenAIApiKey();
  
  if (!apiKey) {
    return {
      success: false,
      error: 'No OpenAI API key found.'
    };
  }
  
  try {
    const openai = new OpenAI({ apiKey: apiKey });
    
    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        {
          role: 'system',
          content: 'You are a recipe parser. Your task is to take a recipe text and extract structured data from it. ' +
            'Identify the title, ingredients, instructions, prep time, cook time, total time, servings, tags, notes, tips, and equipment needed. ' +
            'If the equipment has an affiliate link, include it. Return a JSON object with these fields.'
        },
        {
          role: 'user',
          content: `Parse the following recipe text:\n${text}`
        }
      ],
      temperature: 0.3,
      max_tokens: 2000,
      response_format: { type: 'json_object' }
    });
    
    const content = completion.choices[0].message.content;
    
    if (!content) {
      return {
        success: false,
        error: 'Could not process recipe text.'
      };
    }
    
    const response = JSON.parse(content);
    
    // Process ingredients to ensure they are properly formatted strings
    const processedIngredients = response.ingredients.map((ingredient: any) => {
      if (typeof ingredient === 'string') {
        return ingredient;
      } else if (typeof ingredient === 'object' && ingredient !== null) {
        // Format object to string
        const quantity = ingredient.quantity || '';
        const unit = ingredient.unit || '';
        const name = ingredient.name || '';
        return `${quantity} ${unit} ${name}`.trim();
      }
      return String(ingredient);
    });
    
    // Create the recipe object
    const recipe: RecipeData = {
      title: response.title || 'Untitled Recipe',
      introduction: response.introduction || response.description || '',
      ingredients: processedIngredients,
      instructions: response.instructions || response.steps || [],
      prepTime: response.prepTime || response.prep_time || '',
      cookTime: response.cookTime || response.cook_time || '',
      totalTime: response.totalTime || response.total_time || '',
      servings: response.servings || '',
      tags: response.tags || [],
      notes: response.notes || [],
      tips: response.tips || [],
      proTips: response.proTips || response.pro_tips || [],
      equipmentNeeded: (response.equipment || []).map((item: string | any) => {
        if (typeof item === 'string') {
          return {
            id: uuidv4(),
            name: item
          };
        } else {
          return {
            id: item.id || uuidv4(),
            name: item.name || 'Equipment',
            affiliateLink: item.affiliateLink || item.affiliate_link
          };
        }
      }),
      equipment: response.equipment || [],
      // Set recipe metadata
      isConverted: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      imageUrl: response.imageUrl || defaultRecipeImage
    };
    
    logInfo('Recipe processed successfully', { title: recipe.title });
    
    return {
      success: true,
      recipe: recipe
    };
  } catch (error) {
    logError('Error processing recipe text with OpenAI', { error });
    return {
      success: false,
      error: 'Failed to process recipe text with OpenAI.'
    };
  }
};
